{
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "schemes": [
    "http"
  ],
  "swagger": "2.0",
  "info": {
    "description": "Documentation of our go API.",
    "title": "goAPI.",
    "version": "1.0.0"
  },
  "host": "some-url.com",
  "basePath": "/",
  "paths": {
    "/v1/admin/tsdb/clean_tombstones": {
      "put": {
        "description": "This can be used after deleting series to free up space. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "removes the deleted data from disk and cleans up the existing tombstones.",
        "operationId": "listcleanTombstonesPUT",
        "responses": {
          "204": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "This can be used after deleting series to free up space. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "removes the deleted data from disk and cleans up the existing tombstones.",
        "operationId": "listcleanTombstonesPOST",
        "responses": {
          "204": {
            "description": ""
          }
        }
      }
    },
    "/v1/admin/tsdb/delete_series": {
      "put": {
        "description": "The actual data still exists on disk and is cleaned up in future compactions or can be explicitly cleaned up by hitting the Clean Tombstones endpoint. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "deletes data for a selection of series in a time range.",
        "operationId": "listdeleteSeriesPUT",
        "responses": {
          "204": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "The actual data still exists on disk and is cleaned up in future compactions or can be explicitly cleaned up by hitting the Clean Tombstones endpoint. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "deletes data for a selection of series in a time range.",
        "operationId": "listdeleteSeriesPOST",
        "responses": {
          "204": {
            "description": ""
          }
        }
      }
    },
    "/v1/admin/tsdb/snapshot": {
      "put": {
        "description": "It will optionally skip snapshotting data that is only present in the head block, and which has not yet been compacted to disk. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "creates a snapshot of all current data into snapshots/\u003cdatetime\u003e-\u003crand\u003e under the TSDB's data directory and returns the directory as response.",
        "operationId": "listsnapshotPUT",
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "It will optionally skip snapshotting data that is only present in the head block, and which has not yet been compacted to disk. New in v2.1 and supports PUT from v2.9",
        "tags": [
          "Admin"
        ],
        "summary": "creates a snapshot of all current data into snapshots/\u003cdatetime\u003e-\u003crand\u003e under the TSDB's data directory and returns the directory as response.",
        "operationId": "listsnapshotPOST",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/alertmanagers": {
      "get": {
        "description": "Both the active and dropped Alertmanagers are part of the response.",
        "tags": [
          "Default"
        ],
        "summary": "returns an overview of the current state of the Prometheus alertmanager discovery.",
        "operationId": "listalertManagers",
        "responses": {
          "200": {
            "$ref": "#/responses/alertManagerDiscoveryStruct"
          }
        }
      }
    },
    "/v1/alerts": {
      "get": {
        "description": "As the /alerts endpoint is fairly new, it does not have the same stability guarantees as the overarching API v1.",
        "tags": [
          "Default"
        ],
        "summary": "returns a list of all active alerts.",
        "operationId": "listAlerts",
        "responses": {
          "200": {
            "$ref": "#/responses/alertStruct"
          }
        }
      }
    },
    "/v1/label/{label_name}/values": {
      "get": {
        "description": "The data section of the JSON response is a list of string label values..",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns a list of label values for a provided label name.",
        "operationId": "listlabelValues",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/labels": {
      "get": {
        "description": "The data section of the JSON response is a list of string label names.",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns a list of label names.",
        "operationId": "listlabelNamesGET",
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "The data section of the JSON response is a list of string label names.",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns a list of label names.",
        "operationId": "listlabelNamesPOST",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/metadata": {
      "get": {
        "description": "However, it does not provide any target information. This is considered experimental and might change in the future. \nThe data section of the query result consists of an object where each key is a metric name and each value is a list of unique metadata objects, as exposed for that metric name across all targets.",
        "tags": [
          "Default"
        ],
        "summary": "returns metadata about metrics currently scrapped from targets.",
        "operationId": "listmetricMetadata",
        "responses": {
          "200": {
            "$ref": "#/responses/metadataStruct"
          }
        }
      }
    },
    "/v1/query": {
      "get": {
        "description": "The current server time is used if the time parameter is omitted. You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "evaluates an instant query at a single point in time.",
        "operationId": "listqueryGET",
        "responses": {
          "200": {
            "$ref": "#/responses/queryDataStruct"
          }
        }
      },
      "post": {
        "description": "The current server time is used if the time parameter is omitted. You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "evaluates an instant query at a single point in time.",
        "operationId": "listqueryPOST",
        "responses": {
          "200": {
            "$ref": "#/responses/queryDataStruct"
          }
        }
      }
    },
    "/v1/query_exemplars": {
      "get": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "returns a list of exemplars for a valid PromQL query for a specific time range.",
        "operationId": "listqueryExemplarsGET",
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "returns a list of exemplars for a valid PromQL query for a specific time range.",
        "operationId": "listqueryExemplarsPOST",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/query_range": {
      "get": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "evaluates an expression query over a range of time.",
        "operationId": "listqueryRangeGET",
        "responses": {
          "200": {
            "$ref": "#/responses/queryDataStruct"
          }
        }
      },
      "post": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large query that may breach server-side URL character limits.",
        "tags": [
          "Querying"
        ],
        "summary": "evaluates an expression query over a range of time.",
        "operationId": "listqueryRangePOST",
        "responses": {
          "200": {
            "$ref": "#/responses/queryDataStruct"
          }
        }
      }
    },
    "/v1/rules": {
      "get": {
        "description": "In addition it returns the currently active alerts fired by the Prometheus instance of each alerting rule.\nAs the /rules endpoint is fairly new, it does not have the same stability guarantees as the overarching API v1.",
        "tags": [
          "Default"
        ],
        "summary": "returns a list of alerting and recording rules that are currently loaded.",
        "operationId": "listrules",
        "responses": {
          "200": {
            "$ref": "#/responses/ruleStruct"
          }
        }
      }
    },
    "/v1/series": {
      "get": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large or dynamic number of series selectors that may breach server-side URL character limits. The data section of the query result consists of a list of objects that contain the label name/value pairs which identify each series.",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns the list of time series that match a certain label set.",
        "operationId": "listseriesGET",
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "post": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large or dynamic number of series selectors that may breach server-side URL character limits. The data section of the query result consists of a list of objects that contain the label name/value pairs which identify each series.",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns the list of time series that match a certain label set.",
        "operationId": "listseriesPOST",
        "responses": {
          "200": {
            "description": ""
          }
        }
      },
      "delete": {
        "description": "You can URL-encode these parameters directly in the request body by using the POST method and Content-Type: application/x-www-form-urlencoded header. This is useful when specifying a large or dynamic number of series selectors that may breach server-side URL character limits. The data section of the query result consists of a list of objects that contain the label name/value pairs which identify each series.",
        "tags": [
          "Querying_metadata"
        ],
        "summary": "returns the list of time series that match a certain label set.",
        "operationId": "listseriesDELETE",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/status/buildinfo": {
      "get": {
        "description": "All values are of the result type string.",
        "tags": [
          "Status"
        ],
        "summary": "returns various build information properties about the Prometheus server.",
        "operationId": "listserveBuildInfo",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/status/config": {
      "get": {
        "description": "The config is returned as dumped YAML file. Due to limitation of the YAML library, YAML comments are not included.",
        "tags": [
          "Status"
        ],
        "summary": "returns currently loaded configuration file.",
        "operationId": "listserveConfig",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/status/flags": {
      "get": {
        "description": "All values are of the result type string.",
        "tags": [
          "Status"
        ],
        "summary": "returns flag values that Prometheus was configured with.",
        "operationId": "listserveFlags",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/status/runtimeinfo": {
      "get": {
        "description": "The returned values are of different types, depending on the nature of the runtime property",
        "tags": [
          "Status"
        ],
        "summary": "returns various runtime information properties about the Prometheus server.",
        "operationId": "listserveRuntimeInfo",
        "responses": {
          "200": {
            "description": ""
          }
        }
      }
    },
    "/v1/status/tsdb": {
      "get": {
        "tags": [
          "Status"
        ],
        "summary": "returns various cardinality statistics about the Prometheus TSDB.",
        "operationId": "listserveTSDBStatus",
        "responses": {
          "200": {
            "$ref": "#/responses/tsdbStatusStruct"
          }
        }
      }
    },
    "/v1/status/walreplay": {
      "get": {
        "description": "read: The number of segments replayed so far. total: The total number segments needed to be replayed. progress: The progress of the replay (0 - 100%). state: The state of the replay. Possible states: - waiting: Waiting for the replay to start. - in progress: The replay is in progress. - done: The replay has finished.",
        "tags": [
          "Status"
        ],
        "summary": "returns information about the WAL replay.",
        "operationId": "listserveWALReplayStatus",
        "responses": {
          "200": {
            "$ref": "#/responses/walReplayStatusStruct"
          }
        }
      }
    },
    "/v1/targets": {
      "get": {
        "description": "Both the active and dropped targets are part of the response by default. labels represents the label set after relabelling has occurred. discoveredLabels represent the unmodified labels retrieved during service discovery before relabelling has occurred.",
        "tags": [
          "Default"
        ],
        "summary": "returns an overview of the current state of the Prometheus target discovery.",
        "operationId": "listTargetMetadata",
        "responses": {
          "200": {
            "$ref": "#/responses/targetStruct"
          }
        }
      }
    },
    "/v1/targets/metadata": {
      "get": {
        "description": "This is experimental and might change in the future.\nThe data section of the query result consists of a list of objects that contain metric metadata and the target label set.",
        "tags": [
          "Default"
        ],
        "summary": "returns metadata about metrics currently scraped from targets.",
        "operationId": "listTargetMetadata",
        "responses": {
          "200": {
            "$ref": "#/responses/targetMetadataStruct"
          }
        }
      }
    }
  },
  "definitions": {
    "Alert": {
      "type": "object",
      "title": "Alert has info for an alert.",
      "properties": {
        "activeAt": {
          "type": "string",
          "format": "date-time",
          "x-go-name": "ActiveAt"
        },
        "annotations": {
          "$ref": "#/definitions/Labels"
        },
        "labels": {
          "$ref": "#/definitions/Labels"
        },
        "state": {
          "type": "string",
          "x-go-name": "State"
        },
        "value": {
          "type": "string",
          "x-go-name": "Value"
        }
      },
      "x-go-package": "Porting_GoAPI_to_OpenAPI"
    },
    "AlertmanagerTarget": {
      "type": "object",
      "title": "AlertmanagerTarget has info on one AM.",
      "properties": {
        "url": {
          "type": "string",
          "x-go-name": "URL"
        }
      },
      "x-go-package": "Porting_GoAPI_to_OpenAPI"
    },
    "HeadStats": {
      "type": "object",
      "title": "HeadStats has information about the TSDB head.",
      "properties": {
        "chunkCount": {
          "type": "integer",
          "format": "int64",
          "x-go-name": "ChunkCount"
        },
        "maxTime": {
          "type": "integer",
          "format": "int64",
          "x-go-name": "MaxTime"
        },
        "minTime": {
          "type": "integer",
          "format": "int64",
          "x-go-name": "MinTime"
        },
        "numLabelPairs": {
          "type": "integer",
          "format": "int64",
          "x-go-name": "NumLabelPairs"
        },
        "numSeries": {
          "type": "integer",
          "format": "uint64",
          "x-go-name": "NumSeries"
        }
      },
      "x-go-package": "Porting_GoAPI_to_OpenAPI"
    },
    "Label": {
      "type": "object",
      "title": "Label is a key/value pair of strings.",
      "properties": {
        "Name": {
          "type": "string",
          "x-go-name": "Value"
        }
      },
      "x-go-package": "github.com/prometheus/prometheus/pkg/labels"
    },
    "Labels": {
      "description": "Labels is a sorted set of labels. Order has to be guaranteed upon\ninstantiation.",
      "type": "array",
      "items": {
        "$ref": "#/definitions/Label"
      },
      "x-go-package": "github.com/prometheus/prometheus/pkg/labels"
    },
    "MetricType": {
      "type": "string",
      "title": "MetricType represents metric type values.",
      "x-go-package": "github.com/prometheus/prometheus/pkg/textparse"
    },
    "QueryStats": {
      "type": "object",
      "title": "QueryStats currently only holding query timings.",
      "properties": {
        "timings": {
          "$ref": "#/definitions/queryTimings"
        }
      },
      "x-go-package": "github.com/prometheus/prometheus/util/stats"
    },
    "RuleHealth": {
      "type": "string",
      "title": "RuleHealth describes the health state of a rule.",
      "x-go-package": "github.com/prometheus/prometheus/rules"
    },
    "TargetHealth": {
      "type": "string",
      "title": "TargetHealth describes the health state of a target.",
      "x-go-package": "github.com/prometheus/prometheus/scrape"
    },
    "Value": {
      "type": "object",
      "title": "Value is a generic interface for values resulting from a query evaluation.",
      "properties": {
        "String": {
          "type": "string"
        },
        "Type": {
          "$ref": "#/definitions/ValueType"
        }
      },
      "x-go-package": "github.com/prometheus/prometheus/promql/parser"
    },
    "ValueType": {
      "type": "string",
      "title": "ValueType describes a type of a value.",
      "x-go-package": "github.com/prometheus/prometheus/promql/parser"
    },
    "queryTimings": {
      "type": "object",
      "title": "queryTimings with all query timers mapped to durations.",
      "properties": {
        "evalTotalTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "EvalTotalTime"
        },
        "execQueueTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "ExecQueueTime"
        },
        "execTotalTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "ExecTotalTime"
        },
        "innerEvalTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "InnerEvalTime"
        },
        "queryPreparationTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "QueryPreparationTime"
        },
        "resultSortTime": {
          "type": "number",
          "format": "double",
          "x-go-name": "ResultSortTime"
        }
      },
      "x-go-package": "github.com/prometheus/prometheus/util/stats"
    },
    "stat": {
      "type": "object",
      "title": "stat holds the information about individual cardinality.",
      "properties": {
        "name": {
          "type": "string",
          "x-go-name": "Name"
        },
        "value": {
          "type": "integer",
          "format": "uint64",
          "x-go-name": "Value"
        }
      },
      "x-go-package": "Porting_GoAPI_to_OpenAPI"
    }
  },
  "responses": {
    "alertManagerDiscoveryStruct": {
      "description": "AlertmanagerDiscovery has all the active Alertmanagers.",
      "headers": {
        "activeAlertmanagers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AlertmanagerTarget"
          }
        },
        "droppedAlertmanagers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AlertmanagerTarget"
          }
        }
      }
    },
    "alertStruct": {
      "description": "Alert has info for an alert.",
      "schema": {
        "$ref": "#/definitions/Labels"
      },
      "headers": {
        "activeAt": {
          "type": "string",
          "format": "date-time"
        },
        "annotations": {},
        "labels": {},
        "state": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "metadataStruct": {
      "description": "",
      "schema": {
        "$ref": "#/definitions/MetricType"
      },
      "headers": {
        "help": {
          "type": "string"
        },
        "type": {},
        "unit": {
          "type": "string"
        }
      }
    },
    "queryDataStruct": {
      "description": "",
      "schema": {
        "$ref": "#/definitions/QueryStats"
      },
      "headers": {
        "result": {},
        "resultType": {},
        "stats": {}
      }
    },
    "ruleStruct": {
      "description": "",
      "schema": {
        "$ref": "#/definitions/RuleHealth"
      },
      "headers": {
        "alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/Alert"
          }
        },
        "annotations": {},
        "duration": {
          "type": "number",
          "format": "double"
        },
        "evaluationTime": {
          "type": "number",
          "format": "double"
        },
        "health": {},
        "labels": {},
        "lastError": {
          "type": "string"
        },
        "lastEvaluation": {
          "type": "string",
          "format": "date-time"
        },
        "name": {
          "type": "string"
        },
        "query": {
          "type": "string"
        },
        "state": {
          "type": "string",
          "description": "State can be \"pending\", \"firing\", \"inactive\"."
        },
        "type": {
          "type": "string",
          "description": "Type of an alertingRule is always \"alerting\"."
        }
      }
    },
    "targetMetadataStruct": {
      "description": "",
      "schema": {
        "$ref": "#/definitions/MetricType"
      },
      "headers": {
        "help": {
          "type": "string"
        },
        "metric": {
          "type": "string"
        },
        "target": {},
        "type": {},
        "unit": {
          "type": "string"
        }
      }
    },
    "targetStruct": {
      "description": "Target has the information for one target.",
      "schema": {
        "type": "object",
        "additionalProperties": {
          "type": "string"
        },
        "$ref": "#/definitions/TargetHealth"
      },
      "headers": {
        "discoveredLabels": {
          "description": "Labels before any processing."
        },
        "globalUrl": {
          "type": "string"
        },
        "health": {},
        "labels": {
          "description": "Any labels that are added to this target and its metrics."
        },
        "lastError": {
          "type": "string"
        },
        "lastScrape": {
          "type": "string",
          "format": "date-time"
        },
        "lastScrapeDuration": {
          "type": "number",
          "format": "double"
        },
        "scrapePool": {
          "type": "string"
        },
        "scrapeUrl": {
          "type": "string"
        }
      }
    },
    "tsdbStatusStruct": {
      "description": "tsdbStatus has information of cardinality statistics from postings.",
      "schema": {
        "$ref": "#/definitions/HeadStats"
      },
      "headers": {
        "headStats": {
          "description": "This provides the following data about the head block of the TSDB."
        },
        "labelValueCountByLabelName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/stat"
          },
          "description": "This will provide a list of the label names and their value count."
        },
        "memoryInBytesByLabelName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/stat"
          },
          "description": "This will provide a list of the label names and memory used in bytes. Memory usage is calculated by adding the length of all values for a given label name."
        },
        "seriesCountByLabelValuePair": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/stat"
          },
          "description": "This will provide a list of label value pairs and their series count."
        },
        "seriesCountByMetricName": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/stat"
          },
          "description": "This will provide a list of metrics names and their series count."
        }
      }
    },
    "walReplayStatusStruct": {
      "description": "",
      "headers": {
        "current": {
          "type": "integer",
          "format": "int64"
        },
        "max": {
          "type": "integer",
          "format": "int64"
        },
        "min": {
          "type": "integer",
          "format": "int64"
        }
      }
    }
  },
  "securityDefinitions": {
    "basic": {
      "type": "basic"
    }
  }
}