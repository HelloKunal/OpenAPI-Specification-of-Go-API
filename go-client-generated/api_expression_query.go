
/*
 * Prometheus HTTP API
 *
 * The current stable HTTP API is reachable under /api/v1 on a Prometheus server. Any non-breaking additions will be added under that endpoint.  # Format overview The API response format is JSON. Every successful API request returns a ```2xx``` status code.  Invalid requests that reach the API handlers return a JSON error object and one of the following HTTP response codes:  ```400 Bad Request``` when parameters are missing or incorrect. ```422 Unprocessable Entity``` when an expression can't be executed ([RFC4918](https://datatracker.ietf.org/doc/html/rfc4918#page-78)). ```503 Service Unavailable``` when queries time out or abort.  Other non-```2xx``` codes may be returned for errors occurring before the API endpoint is reached.  An array of warnings may be returned if there are errors that do not inhibit the request execution. All of the data that was successfully collected will be returned in the data field.  The JSON response envelope format is as follows:  ``` {   \"status\": \"success\" | \"error\",   \"data\": <data>,    // Only set if status is \"error\". The data field may still hold   // additional data.   \"errorType\": \"<string>\",   \"error\": \"<string>\",    // Only if there were warnings while executing the request.   // There will still be data in the data field.   \"warnings\": [\"<string>\"] } ``` # Generic placeholders:  ```<rfc3339 | unix_timestamp>```: Input timestamps may be provided either in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) format or as a Unix timestamp in seconds, with optional decimal places for sub-second precision. Output timestamps are always represented as Unix timestamps in seconds.  ```<series_selector>```: Prometheus [time series selectors](https://prometheus.io/docs/prometheus/latest/querying/basics/#time-series-selectors) like ```http_requests_total``` or ```http_requests_total{method=~\"(GET|POST)\"}``` and need to be URL-encoded.  ```<duration>```: [Prometheus duration strings](https://prometheus.io/docs/prometheus/latest/querying/basics/#time_durations). For example, ```5m``` refers to a duration of 5 minutes.  ```<bool>```: boolean values (strings ```true``` and ```false```).  **Note**: Names of query parameters that may be repeated end with ```[]```. 
 *
 * API version: v2
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ExpressionQueryApiService service
/*
ExpressionQueryApiService Returns list of Exemplars
This is &lt;b&gt;experimental&lt;/b&gt; and might change in the future. The following endpoint returns a list of exemplars for a valid PromQL query for a specific time range 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;test_exemplar_metric_total&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryExemplarsGETOpts - Optional Parameters:
     * @param "Start" (optional.String) -  Start timestamp.  Example: &#x60;&#x60;&#x60;&amp;start&#x3D;2020-09-14T15:22:25.479Z&#x60;&#x60;&#x60; 
     * @param "End" (optional.String) -  End timestamp.  Example: &#x60;&#x60;&#x60;&amp;end&#x3D;020-09-14T15:23:25.479Z&#x60;&#x60;&#x60; 
@return ResponseQueryExemplars
*/

type ExpressionQueryApiQueryExemplarsGETOpts struct {
    Start optional.String
    End optional.String
}

func (a *ExpressionQueryApiService) QueryExemplarsGET(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryExemplarsGETOpts) (ResponseQueryExemplars, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseQueryExemplars
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query_exemplars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.End.IsSet() {
		localVarQueryParams.Add("end", parameterToString(localVarOptionals.End.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ResponseQueryExemplars
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExpressionQueryApiService Returns list of Exemplars
This is &lt;b&gt;experimental&lt;/b&gt; and might change in the future. The following endpoint returns a list of exemplars for a valid PromQL query for a specific time range 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;test_exemplar_metric_total&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryExemplarsPOSTOpts - Optional Parameters:
     * @param "Start" (optional.String) -  Start timestamp.  Example: &#x60;&#x60;&#x60;&amp;start&#x3D;2020-09-14T15:22:25.479Z&#x60;&#x60;&#x60; 
     * @param "End" (optional.String) -  End timestamp.  Example: &#x60;&#x60;&#x60;&amp;end&#x3D;020-09-14T15:23:25.479Z&#x60;&#x60;&#x60; 
@return ResponseQueryExemplars
*/

type ExpressionQueryApiQueryExemplarsPOSTOpts struct {
    Start optional.String
    End optional.String
}

func (a *ExpressionQueryApiService) QueryExemplarsPOST(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryExemplarsPOSTOpts) (ResponseQueryExemplars, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseQueryExemplars
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query_exemplars"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.End.IsSet() {
		localVarQueryParams.Add("end", parameterToString(localVarOptionals.End.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ResponseQueryExemplars
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExpressionQueryApiService Evaluates instant query
The following endpoint evaluates an instant query at a single point in time  You can URL-encode these parameters directly in the request body by using the &#x60;&#x60;&#x60;POST&#x60;&#x60;&#x60; method and &#x60;&#x60;&#x60;Content-Type: application/x-www-form-urlencoded&#x60;&#x60;&#x60; header. This is useful when specifying a large query that may breach server-side URL character limits.  The data section of the query result has the following format &#x60;&#x60;&#x60; {   \&quot;resultType\&quot;: \&quot;matrix\&quot; | \&quot;vector\&quot; | \&quot;scalar\&quot; | \&quot;string\&quot;,   \&quot;result\&quot;: &lt;value&gt; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;&lt;value&gt;&#x60;&#x60;&#x60; refers to the query result data, which has varying formats depending on the &#x60;&#x60;&#x60;resultType&#x60;&#x60;&#x60;. See the [expression query result formats](https://prometheus.io/docs/prometheus/latest/querying/api/#expression-query-result-formats). 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;up&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryGETOpts - Optional Parameters:
     * @param "Time" (optional.String) -  Evaluation timestamp. Optional.  The current server time is used if the &#x60;&#x60;&#x60;time&#x60;&#x60;&#x60; parameter is omitted.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
     * @param "Timeout" (optional.String) -  Evaluation timeout. Optional. Defaults to and is capped by the value of the &#x60;&#x60;&#x60;-query.timeout&#x60;&#x60;&#x60; flag.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
@return QueryData
*/

type ExpressionQueryApiQueryGETOpts struct {
    Time optional.String
    Timeout optional.String
}

func (a *ExpressionQueryApiService) QueryGET(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryGETOpts) (QueryData, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QueryData
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Time.IsSet() {
		localVarQueryParams.Add("time", parameterToString(localVarOptionals.Time.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v QueryData
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExpressionQueryApiService Evaluates instant query
The following endpoint evaluates an instant query at a single point in time  You can URL-encode these parameters directly in the request body by using the &#x60;&#x60;&#x60;POST&#x60;&#x60;&#x60; method and &#x60;&#x60;&#x60;Content-Type: application/x-www-form-urlencoded&#x60;&#x60;&#x60; header. This is useful when specifying a large query that may breach server-side URL character limits.  The data section of the query result has the following format &#x60;&#x60;&#x60; {   \&quot;resultType\&quot;: \&quot;matrix\&quot; | \&quot;vector\&quot; | \&quot;scalar\&quot; | \&quot;string\&quot;,   \&quot;result\&quot;: &lt;value&gt; } &#x60;&#x60;&#x60; &#x60;&#x60;&#x60;&lt;value&gt;&#x60;&#x60;&#x60; refers to the query result data, which has varying formats depending on the &#x60;&#x60;&#x60;resultType&#x60;&#x60;&#x60;. See the [expression query result formats](https://prometheus.io/docs/prometheus/latest/querying/api/#expression-query-result-formats). 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;up&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryPOSTOpts - Optional Parameters:
     * @param "Time" (optional.String) -  Evaluation timestamp. Optional.  The current server time is used if the &#x60;&#x60;&#x60;time&#x60;&#x60;&#x60; parameter is omitted.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
     * @param "Timeout" (optional.String) -  Evaluation timeout. Optional. Defaults to and is capped by the value of the &#x60;&#x60;&#x60;-query.timeout&#x60;&#x60;&#x60; flag.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
@return QueryData
*/

type ExpressionQueryApiQueryPOSTOpts struct {
    Time optional.String
    Timeout optional.String
}

func (a *ExpressionQueryApiService) QueryPOST(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryPOSTOpts) (QueryData, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QueryData
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Time.IsSet() {
		localVarQueryParams.Add("time", parameterToString(localVarOptionals.Time.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v QueryData
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExpressionQueryApiService Evaluates query over range of time.
The following endpoint evaluates an expression query over a range of time  You can URL-encode these parameters directly in the request body by using the &#x60;&#x60;&#x60;POST&#x60;&#x60;&#x60; method and &#x60;&#x60;&#x60;Content-Type: application/x-www-form-urlencoded&#x60;&#x60;&#x60; header. This is useful when specifying a large query that may breach server-side URL character limits.  The data section of the query result has the following format &#x60;&#x60;&#x60; {   \&quot;resultType\&quot;: \&quot;matrix\&quot;,   \&quot;result\&quot;: &lt;value&gt; } &#x60;&#x60;&#x60; For the format of the &#x60;&#x60;&#x60;&lt;value&gt;&#x60;&#x60;&#x60; placeholder, see the [range-vector result format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors). 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;up&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryRangeGETOpts - Optional Parameters:
     * @param "Start" (optional.String) -  Start timestamp.  Example: &#x60;&#x60;&#x60;&amp;start&#x3D;2015-07-01T20:10:30.781Z&#x60;&#x60;&#x60; 
     * @param "End" (optional.String) -  End timestamp.  Example: &#x60;&#x60;&#x60;&amp;end&#x3D;2015-07-01T20:11:00.781Z&#x60;&#x60;&#x60; 
     * @param "Step" (optional.String) -  Query resolution step width in &#x60;&#x60;&#x60;duration&#x60;&#x60;&#x60; format or float number of seconds.  Example: &#x60;&#x60;&#x60;&amp;step&#x3D;15s&#x60;&#x60;&#x60; 
     * @param "Timeout" (optional.String) -  Evaluation timeout. Optional. Defaults to and is capped by the value of the &#x60;&#x60;&#x60;-query.timeout&#x60;&#x60;&#x60; flag.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
@return ResponseQueryRange
*/

type ExpressionQueryApiQueryRangeGETOpts struct {
    Start optional.String
    End optional.String
    Step optional.String
    Timeout optional.String
}

func (a *ExpressionQueryApiService) QueryRangeGET(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryRangeGETOpts) (ResponseQueryRange, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseQueryRange
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query_range"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.End.IsSet() {
		localVarQueryParams.Add("end", parameterToString(localVarOptionals.End.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Step.IsSet() {
		localVarQueryParams.Add("step", parameterToString(localVarOptionals.Step.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ResponseQueryRange
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ExpressionQueryApiService Evaluates query over range of time.
The following endpoint evaluates an expression query over a range of time  You can URL-encode these parameters directly in the request body by using the &#x60;&#x60;&#x60;POST&#x60;&#x60;&#x60; method and &#x60;&#x60;&#x60;Content-Type: application/x-www-form-urlencoded&#x60;&#x60;&#x60; header. This is useful when specifying a large query that may breach server-side URL character limits.  The data section of the query result has the following format &#x60;&#x60;&#x60; {   \&quot;resultType\&quot;: \&quot;matrix\&quot;,   \&quot;result\&quot;: &lt;value&gt; } &#x60;&#x60;&#x60; For the format of the &#x60;&#x60;&#x60;&lt;value&gt;&#x60;&#x60;&#x60; placeholder, see the [range-vector result format](https://prometheus.io/docs/prometheus/latest/querying/api/#range-vectors). 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query Prometheus expression query string.  Example: &#x60;&#x60;&#x60;?query&#x3D;up&#x60;&#x60;&#x60; 
 * @param optional nil or *ExpressionQueryApiQueryRangePOSTOpts - Optional Parameters:
     * @param "Start" (optional.String) -  Start timestamp.  Example: &#x60;&#x60;&#x60;&amp;start&#x3D;2015-07-01T20:10:30.781Z&#x60;&#x60;&#x60; 
     * @param "End" (optional.String) -  End timestamp.  Example: &#x60;&#x60;&#x60;&amp;end&#x3D;2015-07-01T20:11:00.781Z&#x60;&#x60;&#x60; 
     * @param "Step" (optional.String) -  Query resolution step width in &#x60;&#x60;&#x60;duration&#x60;&#x60;&#x60; format or float number of seconds.  Example: &#x60;&#x60;&#x60;&amp;step&#x3D;15s&#x60;&#x60;&#x60; 
     * @param "Timeout" (optional.String) -  Evaluation timeout. Optional. Defaults to and is capped by the value of the &#x60;&#x60;&#x60;-query.timeout&#x60;&#x60;&#x60; flag.  Example: &#x60;&#x60;&#x60;?metric&#x3D;http_requests_total&#x60;&#x60;&#x60; 
@return ResponseQueryRange
*/

type ExpressionQueryApiQueryRangePOSTOpts struct {
    Start optional.String
    End optional.String
    Step optional.String
    Timeout optional.String
}

func (a *ExpressionQueryApiService) QueryRangePOST(ctx context.Context, query string, localVarOptionals *ExpressionQueryApiQueryRangePOSTOpts) (ResponseQueryRange, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ResponseQueryRange
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query_range"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.Start.IsSet() {
		localVarQueryParams.Add("start", parameterToString(localVarOptionals.Start.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.End.IsSet() {
		localVarQueryParams.Add("end", parameterToString(localVarOptionals.End.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Step.IsSet() {
		localVarQueryParams.Add("step", parameterToString(localVarOptionals.Step.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Timeout.IsSet() {
		localVarQueryParams.Add("timeout", parameterToString(localVarOptionals.Timeout.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ResponseQueryRange
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
